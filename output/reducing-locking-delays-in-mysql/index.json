{
  "schema_name": "DoclingDocument",
  "version": "1.4.0",
  "name": "index",
  "origin": {
    "mimetype": "text/markdown",
    "binary_hash": 9527442012278909449,
    "filename": "index.md"
  },
  "furniture": {
    "self_ref": "#/furniture",
    "children": [],
    "content_layer": "furniture",
    "name": "_root_",
    "label": "unspecified"
  },
  "body": {
    "self_ref": "#/body",
    "children": [
      {
        "$ref": "#/texts/0"
      },
      {
        "$ref": "#/groups/0"
      },
      {
        "$ref": "#/texts/3"
      },
      {
        "$ref": "#/texts/4"
      },
      {
        "$ref": "#/texts/5"
      },
      {
        "$ref": "#/texts/6"
      },
      {
        "$ref": "#/texts/7"
      },
      {
        "$ref": "#/texts/8"
      },
      {
        "$ref": "#/texts/9"
      },
      {
        "$ref": "#/texts/10"
      },
      {
        "$ref": "#/texts/11"
      },
      {
        "$ref": "#/groups/1"
      },
      {
        "$ref": "#/texts/19"
      },
      {
        "$ref": "#/texts/20"
      },
      {
        "$ref": "#/texts/21"
      },
      {
        "$ref": "#/texts/22"
      },
      {
        "$ref": "#/texts/23"
      },
      {
        "$ref": "#/texts/24"
      },
      {
        "$ref": "#/texts/25"
      },
      {
        "$ref": "#/texts/26"
      },
      {
        "$ref": "#/texts/27"
      },
      {
        "$ref": "#/texts/28"
      },
      {
        "$ref": "#/texts/29"
      },
      {
        "$ref": "#/texts/30"
      },
      {
        "$ref": "#/texts/31"
      },
      {
        "$ref": "#/texts/32"
      },
      {
        "$ref": "#/texts/33"
      },
      {
        "$ref": "#/texts/34"
      },
      {
        "$ref": "#/texts/35"
      }
    ],
    "content_layer": "body",
    "name": "_root_",
    "label": "unspecified"
  },
  "groups": [
    {
      "self_ref": "#/groups/0",
      "parent": {
        "$ref": "#/body"
      },
      "children": [
        {
          "$ref": "#/texts/1"
        },
        {
          "$ref": "#/texts/2"
        }
      ],
      "content_layer": "body",
      "name": "list",
      "label": "list"
    },
    {
      "self_ref": "#/groups/1",
      "parent": {
        "$ref": "#/body"
      },
      "children": [
        {
          "$ref": "#/texts/12"
        },
        {
          "$ref": "#/texts/13"
        },
        {
          "$ref": "#/texts/14"
        },
        {
          "$ref": "#/texts/15"
        },
        {
          "$ref": "#/texts/16"
        },
        {
          "$ref": "#/texts/17"
        },
        {
          "$ref": "#/texts/18"
        }
      ],
      "content_layer": "body",
      "name": "list",
      "label": "list"
    }
  ],
  "texts": [
    {
      "self_ref": "#/texts/0",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "aliases:",
      "text": "aliases:"
    },
    {
      "self_ref": "#/texts/1",
      "parent": {
        "$ref": "#/groups/0"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "/2008/04/16/reducing-locking-delays-in-mysql/",
      "text": "/2008/04/16/reducing-locking-delays-in-mysql/",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/2",
      "parent": {
        "$ref": "#/groups/0"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "database",
      "text": "database",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/3",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Before getting started, it's important to understand why  MySQL  uses  locks . In short - MySQL uses locks to prevent multiple clients from corrupting data due to simultaneous writes while also protecting clients from reading partially-written data.",
      "text": "Before getting started, it's important to understand why  MySQL  uses  locks . In short - MySQL uses locks to prevent multiple clients from corrupting data due to simultaneous writes while also protecting clients from reading partially-written data."
    },
    {
      "self_ref": "#/texts/4",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Some of you may be thinking, \"Okay, this makes sense.\" If that's you, skip the next two paragraphs. If not, keep reading.",
      "text": "Some of you may be thinking, \"Okay, this makes sense.\" If that's you, skip the next two paragraphs. If not, keep reading."
    },
    {
      "self_ref": "#/texts/5",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Analogies can help understand topics like these. Here's one that I came up with during a training class. Consider two people sitting in front of a notepad on a table. Let's say that a sentence like \"The quick brown fox jumps over the lazy dog\" is already written on the notepad. If both people want to read the sentence simultaneously, they can do so without getting in each other's way. A third or fourth person could show up and they could all read it at the same time.",
      "text": "Analogies can help understand topics like these. Here's one that I came up with during a training class. Consider two people sitting in front of a notepad on a table. Let's say that a sentence like \"The quick brown fox jumps over the lazy dog\" is already written on the notepad. If both people want to read the sentence simultaneously, they can do so without getting in each other's way. A third or fourth person could show up and they could all read it at the same time."
    },
    {
      "self_ref": "#/texts/6",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Well, let's say one of the people at the table is writing a screenplay for  Cujo , and they want to change \"lazy\" to \"crazy\". That person erases the \"l\" in \"lazy\" and then adds a \"cr\" to the front to spell \"crazy\". So if the other person is reading the sentence while the first person is writing, they will see \"lazy\" turn into \"azy\", then \"c_azy\", and then finally, \"crazy\". This isn't a big issue in real life, but on the database level, this could be dangerous. If the person who was reading the sentence showed up during the middle of the letter changes, they would think that the dog was \"azy\", and they'd walk away wondering what the adjective \"azy\" means. To get around this, MySQL uses locking to block clients from reading data while it's being written and it blocks clients from writing data simultaneously.",
      "text": "Well, let's say one of the people at the table is writing a screenplay for  Cujo , and they want to change \"lazy\" to \"crazy\". That person erases the \"l\" in \"lazy\" and then adds a \"cr\" to the front to spell \"crazy\". So if the other person is reading the sentence while the first person is writing, they will see \"lazy\" turn into \"azy\", then \"c_azy\", and then finally, \"crazy\". This isn't a big issue in real life, but on the database level, this could be dangerous. If the person who was reading the sentence showed up during the middle of the letter changes, they would think that the dog was \"azy\", and they'd walk away wondering what the adjective \"azy\" means. To get around this, MySQL uses locking to block clients from reading data while it's being written and it blocks clients from writing data simultaneously."
    },
    {
      "self_ref": "#/texts/7",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Now that we're all familiar with what locks are, and why MySQL uses them, let's talk about some ways to reduce the delays caused by locking. Here's some situations you might be running up against:",
      "text": "Now that we're all familiar with what locks are, and why MySQL uses them, let's talk about some ways to reduce the delays caused by locking. Here's some situations you might be running up against:"
    },
    {
      "self_ref": "#/texts/8",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Writes are delayed because reads have locked the tables",
      "text": "Writes are delayed because reads have locked the tables"
    },
    {
      "self_ref": "#/texts/9",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "This is the most common occurrence from the servers that I have seen. When you run a ",
      "text": "This is the most common occurrence from the servers that I have seen. When you run a "
    },
    {
      "self_ref": "#/texts/10",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "SHOW PROCESSLIST",
      "text": "SHOW PROCESSLIST",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/11",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": ", you may see a few reads at the top of the queue that are in the status of \"Copying to tmp table\" and/or \"Sending data\". On optimized servers running optimized queries, these should clear out quickly. If you're finding that they are not clearing out quickly, try the following:",
      "text": ", you may see a few reads at the top of the queue that are in the status of \"Copying to tmp table\" and/or \"Sending data\". On optimized servers running optimized queries, these should clear out quickly. If you're finding that they are not clearing out quickly, try the following:"
    },
    {
      "self_ref": "#/texts/12",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Use ",
      "text": "Use ",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/13",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Add indexes to tables that you query often",
      "text": "Add indexes to tables that you query often",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/14",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Reduce the amount of rows that are being returned per query",
      "text": "Reduce the amount of rows that are being returned per query",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/15",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Upgrade the networking equipment between web and database servers (if applicable)",
      "text": "Upgrade the networking equipment between web and database servers (if applicable)",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/16",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Consider faster hardware with larger amounts of RAM",
      "text": "Consider faster hardware with larger amounts of RAM",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/17",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Use ",
      "text": "Use ",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/18",
      "parent": {
        "$ref": "#/groups/1"
      },
      "children": [],
      "content_layer": "body",
      "label": "list_item",
      "prov": [],
      "orig": "Consider moving to InnoDB to utilize row-based locking",
      "text": "Consider moving to InnoDB to utilize row-based locking",
      "enumerated": false,
      "marker": "-"
    },
    {
      "self_ref": "#/texts/19",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Reads and writes are delayed because writes have locked the tables",
      "text": "Reads and writes are delayed because writes have locked the tables"
    },
    {
      "self_ref": "#/texts/20",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "Situations like these are a little different. There's two main factors to consider here: either MySQL cannot write data to the disk fast enough, or your write queries (or tables) are not optimized. If you suspect a hardware issue, check your iowait with ",
      "text": "Situations like these are a little different. There's two main factors to consider here: either MySQL cannot write data to the disk fast enough, or your write queries (or tables) are not optimized. If you suspect a hardware issue, check your iowait with "
    },
    {
      "self_ref": "#/texts/21",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "sar",
      "text": "sar",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/22",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": " and see if it stays at about 10-20% or higher during the day. If it does, slow hardware may be the culprit. Try moving to SCSI disks and be sure to use RAID 5 or 10 for additional reliability and speed. SAN or DAS units may also help due to higher throughput and more disk spindles.",
      "text": " and see if it stays at about 10-20% or higher during the day. If it does, slow hardware may be the culprit. Try moving to SCSI disks and be sure to use RAID 5 or 10 for additional reliability and speed. SAN or DAS units may also help due to higher throughput and more disk spindles."
    },
    {
      "self_ref": "#/texts/23",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "If you already have state-of-the-art hardware, be sure that your tables and queries are optimized. Run ",
      "text": "If you already have state-of-the-art hardware, be sure that your tables and queries are optimized. Run "
    },
    {
      "self_ref": "#/texts/24",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "OPTIMIZE TABLES",
      "text": "OPTIMIZE TABLES",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/25",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": " regularly if your data changes often to defragment the tables and clear out any holes from removed or updated data. Slow ",
      "text": " regularly if your data changes often to defragment the tables and clear out any holes from removed or updated data. Slow "
    },
    {
      "self_ref": "#/texts/26",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "UPDATE",
      "text": "UPDATE",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/27",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": " queries suggest that you are updating too many rows, or you may be using a column in the WHERE clause that is not indexed. If you do a large amount of ",
      "text": " queries suggest that you are updating too many rows, or you may be using a column in the WHERE clause that is not indexed. If you do a large amount of "
    },
    {
      "self_ref": "#/texts/28",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "INSERT",
      "text": "INSERT",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/29",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": " queries, use this syntax to enter multiple rows simultaneously:",
      "text": " queries, use this syntax to enter multiple rows simultaneously:"
    },
    {
      "self_ref": "#/texts/30",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "INSERT INTO table (col1,col2) VALUES ('a','1'), ('b','2'), ('c','3');",
      "text": "INSERT INTO table (col1,col2) VALUES ('a','1'), ('b','2'), ('c','3');",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/31",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "This syntax tells MySQL to hold off on updating indexes until the entire query is complete. If you are updating a  very large  amount of rows, and you need to use multiple queries to avoid reaching the  max allowed packet  directive, you can do something like this:",
      "text": "This syntax tells MySQL to hold off on updating indexes until the entire query is complete. If you are updating a  very large  amount of rows, and you need to use multiple queries to avoid reaching the  max allowed packet  directive, you can do something like this:"
    },
    {
      "self_ref": "#/texts/32",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "ALTER TABLE table DISABLE KEYS;\nINSERT INTO table (col1,col2) VALUES ('a','1'), ('b','2'), ('c','3');\n~~~ many more inserts ~~~\nALTER TABLE table ENABLE KEYS;",
      "text": "ALTER TABLE table DISABLE KEYS;\nINSERT INTO table (col1,col2) VALUES ('a','1'), ('b','2'), ('c','3');\n~~~ many more inserts ~~~\nALTER TABLE table ENABLE KEYS;",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/33",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": "This forces MySQL to not calculate any new index information until you re-enable the keys or run ",
      "text": "This forces MySQL to not calculate any new index information until you re-enable the keys or run "
    },
    {
      "self_ref": "#/texts/34",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "code",
      "prov": [],
      "orig": "OPTIMIZE TABLE",
      "text": "OPTIMIZE TABLE",
      "captions": [],
      "references": [],
      "footnotes": [],
      "code_language": "unknown"
    },
    {
      "self_ref": "#/texts/35",
      "parent": {
        "$ref": "#/body"
      },
      "children": [],
      "content_layer": "body",
      "label": "paragraph",
      "prov": [],
      "orig": ". If all of this does not help, consider using InnoDB as your storage engine. You can benefit from the row-level locking, which reduces locking in mixed read/write scenarios. In addition, InnoDB is able to write data much more efficiently than MyISAM.",
      "text": ". If all of this does not help, consider using InnoDB as your storage engine. You can benefit from the row-level locking, which reduces locking in mixed read/write scenarios. In addition, InnoDB is able to write data much more efficiently than MyISAM."
    }
  ],
  "pictures": [],
  "tables": [],
  "key_value_items": [],
  "form_items": [],
  "pages": {}
}